#!/usr/bin/env python
""" 
    Helper to load the included CA bundle, derived from the
    official Mozilla CA root trust file located at:

    http://mxr.mozilla.org/mozilla-release/source/security/nss/lib/ckfw/builtins/certdata.txt?raw=1

    Copyright (c) 2013-2015, eGenix.com Software GmbH; mailto:info@egenix.com
    See the documentation for further information on copyrights,
    or contact the author. All Rights Reserved.

"""
import os, re

# Module location
MODULE_PATH = os.path.abspath(os.path.join(os.getcwd(), __file__))
MODULE_DIR = os.path.split(MODULE_PATH)[0]

# Bundle file certificate parser
BUNDLE_RX = re.compile(
    'Certificate "(?P<name>[^"\n]+)"\n'
    '=+\n'
    '\n*'
    'SHA1 Fingerprint=(?P<sha1>[0-9A-F:]+)\n'
    'Certificate:\n'
    '(?P<description>'
    '.+?'
    ')'
    '(?P<certificate>'
    '-----BEGIN [A-Z ]*CERTIFICATE-----\n'
    '[^-]+'
    '-----END [A-Z ]*CERTIFICATE-----\n'
    ')',
    re.DOTALL)

# Trusted purposes
TRUST_SERVER_AUTHENTICATION = 'serverAuth'
TRUST_EMAIL_PROTECTION = 'emailProtection'
TRUST_CODE_SIGNING = 'codeSigning'
TRUST_ANY = 'any'

# Bundle names
TRUST_BUNDLE = {
    TRUST_SERVER_AUTHENTICATION: 'ca-bundle-server.crt',
    TRUST_EMAIL_PROTECTION: 'ca-bundle-email.crt',
    TRUST_CODE_SIGNING: 'ca-bundle-codesigning.crt',
    TRUST_ANY: 'ca-bundle.crt',
    }

###

class CARootCertificate:

    """ CA Root Certificate

        Provides access to the data stored for each certificate in the
        CA bundle.

    """
    # Name of the certificate
    name = ''

    # SHA1 fingerprint using 2-digit-hex colon separated format (the
    # OpenSSL format used by .digest())
    sha1 = ''

    # Text description
    description = ''

    # Certificate in PEM format
    certificate = ''

    def __init__(self, name, sha1, description, certificate):

        self.name = name
        self.sha1 = sha1
        self.description = description
        self.certificate = certificate

    def get_x509(self):

        """ Return the certificate as pyOpenSSL X509 object.

        """
        from OpenSSL import crypto
        return crypto.load_certificate(crypto.FILETYPE_PEM,
                                       self.certificate)

    def hexdigest(self):

        """ Return the SHA1 fingerprint in the Python .hexdigest()
            format (two digit lower case hex numbers).

        """
        return self.sha1.replace(':', '').lower()

### Helpers

def get_ca_bundle_path(purpose=TRUST_ANY):

    """ Return the absolute file path to the CA root certificate
        bundle file.

        purpose may be given to narrow down the trusted purpose.
        Possible values are the TRUST_* values defined at module
        scope. Default is TRUST_ANY. If TRUST_ANY is given, any
        certificate trusted for at least one purpose is included.

        This can be passed to the pyOpenSSL Context method
        .load_verify_locations(pemfile, capath) as pemfile.

    """
    bundle = TRUST_BUNDLE[purpose]
    return os.path.join(MODULE_DIR, bundle)

def get_ca_bundle(path=None, purpose=TRUST_ANY):

    """ Return the CA root certificate bundle as text.

        path defaults to the path returned by
        get_ca_bundle_path(purpose), if not given.

        purpose may be given to narrow down the trusted purpose.
        Possible values are the TRUST_* values defined at module
        scope. Default is TRUST_ANY. If TRUST_ANY is given, any
        certificate trusted for at least one purpose is included.

    """
    if path is None:
        path = get_ca_bundle_path(purpose)
    f = open(path, 'r')
    try:
        return f.read()
    finally:
        f.close()

def iter_ca_bundle(bundle=None, purpose=TRUST_ANY):

    """ Iterate over all certificates in the CA root certificate
        bundle and return them as CARootCertificate instances.

        bundle defaults to the included default CA root certificate
        bundle, if not given.

        purpose has the same meaning as for get_ca_bundle(). It is
        only used if bundle is not given.
        
    """
    if bundle is None:
        bundle = get_ca_bundle(purpose=purpose)
    for m in BUNDLE_RX.finditer(bundle):
        yield CARootCertificate(
            name = m.group('name'),
            sha1 = m.group('sha1'),
            description = m.group('description'),
            certificate = m.group('certificate'),
            )

def iter_ca_bundle_x509(bundle=None, purpose=TRUST_ANY):

    """ Iterate over all certificates in the CA root certificate
        bundle and return them as x509 instances.

        bundle defaults to the included CA root certificate bundle, if
        not given.
        
        purpose has the same meaning as for get_ca_bundle(). It is
        only used if bundle is not given.
        
        This can be used to load trusted certificates into the
        pyOpenSSL Context certificate store and provides a way to load
        the certificates without going through the file system.

    """
    for cert in iter_ca_bundle(bundle, purpose=purpose):
        yield cert.get_x509()

### Command-line interface & testing

if __name__ == '__main__':
    import sys
    purposes = sys.argv[1:]
    if not purposes:
        purposes = [TRUST_ANY]
    for purpose in purposes:
        print ('CA root certificate bundle path for purpose %r' % purpose)
        print ('-' * 72)
        print ('  %s' % get_ca_bundle_path(purpose))
        print ('')
        print ('CA root certificates (name: SHA1 fingerprint)')
        print ('-' * 72)
        l = list(iter_ca_bundle(purpose=purpose))
        l.sort(key=lambda cert: cert.name)
        for cert in l:
            print ('  %s:' % cert.name)
            print ('    .sha1 = %s' % cert.sha1)
            print ('    .description = %s' % cert.description)
            print ('    .certificate = %s' % cert.certificate)
            x509 = cert.get_x509()
            sha1 = x509.digest('SHA1')
            assert cert.sha1 == sha1, 'SHA1 fingeprint mismatch'
        print ('')
